# IMPORTANT:
# Shader passes need to know details about the image in the mask_texture LUT
# files, so set the following constants in user-preset-constants.h accordingly:
# 1.) mask_triads_per_tile = (number of horizontal triads in mask texture LUT's)
# 2.) mask_texture_small_size = (texture size of mask*texture_small LUT's)
# 3.) mask_texture_large_size = (texture size of mask*texture_large LUT's)
# 4.) mask_grille_avg_color = (avg. brightness of mask_grille_texture* LUT's, in [0, 1])
# 5.) mask_slot_avg_color = (avg. brightness of mask_slot_texture* LUT's, in [0, 1])
# 6.) mask_shadow_avg_color = (avg. brightness of mask_shadow_texture* LUT's, in [0, 1])
# Shader passes also need to know certain scales set in this preset, but their
# compilation model doesn't currently allow the preset file to tell them.  Make
# sure to set the following constants in user-preset-constants.h accordingly too:
# 1.) bloom_approx_scale_x = scale_x2
# 2.) mask_resize_viewport_scale = vec2(scale_x6, scale_y5)
# Finally, shader passes need to know the value of geom_max_aspect_ratio used to
# calculate scale_y5 (among other values):
# 1.) geom_max_aspect_ratio = (geom_max_aspect_ratio used to calculate scale_y5)

shaders = "1"//"12"

# Set an identifier, filename, and sampling traits for the phosphor mask texture.
# Load an aperture grille, slot mask, and an EDP shadow mask, and load a small
# non-mipmapped version and a large mipmapped version.
# TODO: Test masks in other directories.
textures = "mask_grille_texture_small;mask_grille_texture_large;mask_slot_texture_small;mask_slot_texture_large;mask_shadow_texture_small;mask_shadow_texture_large"
mask_grille_texture_small = "shaders/crt-royale/TileableLinearApertureGrille15Wide8And5d5SpacingResizeTo64.png"
mask_grille_texture_large = "shaders/crt-royale/TileableLinearApertureGrille15Wide8And5d5Spacing.png"
mask_slot_texture_small = "shaders/crt-royale/TileableLinearSlotMaskTall15Wide9And4d5Horizontal9d14VerticalSpacingResizeTo64.png"
mask_slot_texture_large = "shaders/crt-royale/TileableLinearSlotMaskTall15Wide9And4d5Horizontal9d14VerticalSpacing.png"
mask_shadow_texture_small = "shaders/crt-royale/TileableLinearShadowMaskEDPResizeTo64.png"
mask_shadow_texture_large = "shaders/crt-royale/TileableLinearShadowMaskEDP.png"
mask_grille_texture_small_wrap_mode = "repeat"
mask_grille_texture_large_wrap_mode = "repeat"
mask_slot_texture_small_wrap_mode = "repeat"
mask_slot_texture_large_wrap_mode = "repeat"
mask_shadow_texture_small_wrap_mode = "repeat"
mask_shadow_texture_large_wrap_mode = "repeat"
mask_grille_texture_small_linear = "true"
mask_grille_texture_large_linear = "true"
mask_slot_texture_small_linear = "true"
mask_slot_texture_large_linear = "true"
mask_shadow_texture_small_linear = "true"
mask_shadow_texture_large_linear = "true"
mask_grille_texture_small_mipmap = "false"  # Mipmapping causes artifacts with manually resized masks without tex2Dlod
mask_grille_texture_large_mipmap = "true"   # Essential for hardware-resized masks
mask_slot_texture_small_mipmap = "false"    # Mipmapping causes artifacts with manually resized masks without tex2Dlod
mask_slot_texture_large_mipmap = "true"     # Essential for hardware-resized masks
mask_shadow_texture_small_mipmap = "false"  # Mipmapping causes artifacts with manually resized masks without tex2Dlod
mask_shadow_texture_large_mipmap = "true"   # Essential for hardware-resized masks


# Pass5: Lanczos-resize the phosphor mask vertically.  Set the absolute
# scale_x5 == mask_texture_small_size.x (see IMPORTANT above).  Larger scales
# will blur, and smaller scales could get nasty.  The vertical size must be
# based on the viewport size and calculated carefully to avoid artifacts later.
# First calculate the minimum number of mask tiles we need to draw.
# Since curvature is computed after the scanline masking pass:
#   num_resized_mask_tiles = 2.0;
# If curvature were computed in the scanline masking pass (it's not):
#   max_mask_texel_border = ~3.0 * (1/3.0 + 4.0*sqrt(2.0) + 0.5 + 1.0);
#   max_mask_tile_border = max_mask_texel_border/
#       (min_resized_phosphor_triad_size * mask_triads_per_tile);
#   num_resized_mask_tiles = max(2.0, 1.0 + max_mask_tile_border * 2.0);
#   At typical values (triad_size >= 2.0, mask_triads_per_tile == 8):
#       num_resized_mask_tiles = ~3.8
# Triad sizes are given in horizontal terms, so we need geom_max_aspect_ratio
# to relate them to vertical resolution.  The widest we expect is:
#   geom_max_aspect_ratio = 4.0/3.0  # Note: Shader passes need to know this!
# The fewer triads we tile across the screen, the larger each triad will be as a
# fraction of the viewport size, and the larger scale_y5 must be to draw a full
# num_resized_mask_tiles.  Therefore, we must decide the smallest number of
# triads we'll guarantee can be displayed on screen.  We'll set this according
# to 3-pixel triads at 768p resolution (the lowest anyone's likely to use):
#   min_allowed_viewport_triads = 768.0*geom_max_aspect_ratio / 3.0 = 341.333333
# Now calculate the viewport scale that ensures we can draw resized_mask_tiles:
#   min_scale_x = resized_mask_tiles * mask_triads_per_tile /
#       min_allowed_viewport_triads
#   scale_y5 = geom_max_aspect_ratio * min_scale_x
#   # Some code might depend on equal scales:
#   scale_x6 = scale_y5
# Given our default geom_max_aspect_ratio and min_allowed_viewport_triads:
#   scale_y5 = 4.0/3.0 * 2.0/(341.33333 / 8.0) = 0.0625
# IMPORTANT: The scales MUST be calculated in this way.  If you wish to change
# geom_max_aspect_ratio, update that constant in user-preset-constants.h!
shader0 = "shaders/crt-royale/src/crt-royale-mask-resize-vertical.slang"
filter_linear0 = "true"
scale_type_x0 = "absolute"
scale_x0 = "64"
scale_type_y0 = "viewport"
scale_y0 = "0.0625" # Safe for >= 341.333 horizontal triads at viewport size
#srgb_framebuffer0 = "false" # mask_texture is already assumed linear

